#include <avr/interrupt.h>
#include <EEPROM.h>

// BTS7960 - động cơ trái
#define LPWM_L 5
#define RPWM_L 6
// BTS7960 - động cơ phải
#define LPWM_R 10
#define RPWM_R 11

#define BUZZER 4    // chân điều khiển loa
#define BUTTON1 9   // nút nhấn 1
#define BUTTON2 8   // nút nhấn 2
#define BUTTON3 7   // nút nhấn 3

//---------------------------------------------------//
// KHAI BÁO CÁC BIẾN
int addr = 0;                          
volatile int lastPos;                  
volatile unsigned char isCalib = 0;    
volatile int servoPwm;                 
volatile unsigned char sensor;         
unsigned int sensorValue[8];           
unsigned int sensorPID[8];             
unsigned int black_value[8];           
unsigned int white_value[8];           
unsigned int compare_value[8];         
int speed_run_forward;                 
int cnt = 0;                           
unsigned char pattern, start;          
int line = 0;                          
int RememberLine = 0;                  
float kp = 1.2;                        // Tăng P để phản ứng nhanh hơn
float kd = 8.0;                        // Giảm D để không quá ì
int lostLineCounter = 0;               // Đếm số lần mất line liên tiếp
bool isHighSpeed = false;              // Cờ chế độ tốc độ cao

//---------------------------------------------------//
void setup() {
  pinMode(BUZZER, OUTPUT);
  digitalWrite(BUZZER, LOW);

  pinMode(BUTTON1, INPUT_PULLUP);
  pinMode(BUTTON2, INPUT_PULLUP);
  pinMode(BUTTON3, INPUT_PULLUP);

  pinMode(LPWM_L, OUTPUT);
  pinMode(RPWM_L, OUTPUT);
  pinMode(LPWM_R, OUTPUT);
  pinMode(RPWM_R, OUTPUT);

  speed_run_forward = 80;  // Tốc độ trung bình cao
  speed_run(0, 0);
  pattern = 10;
  start = 0;
  readEeprom();
  Serial.begin(9600);

  // Âm thanh khởi động
  for (int i = 2000; i < 3500; i += 500) {
    tone(BUZZER, i, 100);
    delay(100);
  }

  timer_init();
  isCalib = 1;
}

//---------------------------------------------------//
void timer_init() {
  ASSR = 0;
  TCCR2A = 0;

  TCCR2B = (1 << CS22) | (1 << CS21) | (1 << CS20); // prescale 1024
  TCNT2 = 0xB2;
  TIMSK2 = (1 << TOIE2); // enable overflow interrupt
}


ISR(TIMER2_OVF_vect) {
  TCNT2 = 0xB2;
  read_sensor();
  cnt++;
}

//---------------------------------------------------//
void loop() {
  while (start == 0) {
    updateLine();                     
    if (digitalRead(BUTTON1) == 0) {      // Chế độ ổn định
      start = 1;
      isCalib = 0;
      cnt = 0;
      speed_run_forward = 70;
      isHighSpeed = false;
      beep(100);
      delay(100);
    }
    if (digitalRead(BUTTON2) == 0) {      // Chế độ cân bằng
      start = 1;
      isCalib = 0;
      cnt = 0;
      speed_run_forward = 85;
      isHighSpeed = true;
      beep(100);
      delay(100);
      beep(200);
      delay(100);
    }
    if (digitalRead(BUTTON3) == 0) {      // Chế độ tốc độ cao
      start = 1;
      isCalib = 0;
      cnt = 0;
      speed_run_forward = 87;
      isHighSpeed = true;
      beep(100);
      delay(100);
      beep(200);
      delay(100);
      beep(100);
      delay(100);
    }
  }

  switch (pattern) {
    case 10:  // Khởi động mềm
      if (cnt >= 40) {
        pattern = 11;
        cnt = 0;
        break;
      }
      runforwardline(speed_run_forward + 20); // Tăng tốc ban đầu
      break;

    case 11:  // Chạy line bình thường
    
      // Ghi nhớ hướng line gần nhất
      if (sensorMask(0x01) == 0x01) {
        RememberLine = 1;
        cnt = 0;
      } else if (sensorMask(0x80) == 0x80) {
        RememberLine = -1;
        cnt = 0;
      }
      if (cnt > 300) RememberLine = 0; // Reset sau thời gian dài

      // Xử lý khi mất line
      if (sensor == 0x00) {
        lostLineCounter++;
        if (lostLineCounter > 3) {        // Mất line thật sự
          if (RememberLine != 0) {
            pattern = 12;
          } else {
            // Quay tròn tìm line
            speed_run(60, -60);
          }
        } else {
          // Mất line tạm thời, tiếp tục với PID cuối
          handleAndSpeed(servoPwm, speed_run_forward * 0.7);
        }
        break;
      } else {
        lostLineCounter = 0; // Reset counter khi thấy line
        runforwardline(speed_run_forward);
      }
      break;

    case 12:  // Xử lý tìm lại line
      if (RememberLine == 1) {
        speed_run(speed_run_forward, -50);
        pattern = 21;
        break;
      } else if (RememberLine == -1) {
        speed_run(-50, speed_run_forward);
        pattern = 31;
        break;
      } else {
        pattern = 11;
        break;
      }

    case 21:  // Rẽ phải tìm line
      speed_run(speed_run_forward, -50);
      if (sensorMask(0x07) != 0) { // Thấy line bên phải
        speed_run(speed_run_forward, speed_run_forward / 2);
        pattern = 22;
      }
      break;

    case 22:  // Cân bằng sau rẽ phải
      speed_run(speed_run_forward, speed_run_forward / 2);
      if (sensorMask(0x18) != 0) { // Line về giữa
        pattern = 11;
        RememberLine = 0;
      }
      break;

    case 31:  // Rẽ trái tìm line
      speed_run(-50, speed_run_forward);
      if (sensorMask(0xE0) != 0) { // Thấy line bên trái
        speed_run(speed_run_forward / 2, speed_run_forward);
        pattern = 32;
      }
      break;

    case 32:  // Cân bằng sau rẽ trái
      speed_run(speed_run_forward / 2, speed_run_forward);
      if (sensorMask(0x18) != 0) { // Line về giữa
        pattern = 11;
        RememberLine = 0;
      }
      break;

    case 100:  // Dừng
      speed_run(0, 0);
      beep(200);
      break;

    default:
      pattern = 11;
      break;
  }
}

//---------------------------------------------------//
void runforwardline(int tocdo) {
  // Kết hợp PID liên tục với logic xử lý đặc biệt
  int adjustedSpeed = tocdo;
  int pidAdjust = servoPwm;
  
  // Xử lý các trường hợp đặc biệt dựa trên sensor pattern
  switch (sensor) {
    // Line ở giữa - tăng tốc
    case 0b00011000:
    case 0b00111000:
    case 0b00011100:
    case 0b00111100:
      line = 0;
      adjustedSpeed = tocdo + (isHighSpeed ? 15 : 10); // Boost tốc độ
      kd = 6.0; // Giảm D để mượt hơn ở tốc độ cao
      break;

    // Line lệch nhẹ - tốc độ bình thường
    case 0b00001100:
    case 0b00110000:
    case 0b00000110:
    case 0b01100000:
      line = (sensor & 0x0F) ? 1 : -1;
      adjustedSpeed = tocdo;
      kd = 8.0;
      break;

    // Line lệch nhiều - giảm tốc để rẽ chính xác
    case 0b00000011:
    case 0b00000001:
    case 0b11000000:
    case 0b10000000:
      line = (sensor & 0x0F) ? 2 : -2;
      adjustedSpeed = tocdo * 0.8; // Giảm 20% tốc độ
      kd = 10.0; // Tăng D để ổn định
      break;

    // Line rất lệch hoặc góc cua - giảm tốc mạnh
    case 0b00001111:
    case 0b00011111:
    case 0b11110000:
    case 0b11111000:
      line = (sensor & 0x0F) ? 3 : -3;
      adjustedSpeed = tocdo * 0.6; // Giảm 40% tốc độ
      kd = 12.0;
      break;

    // Đường thẳng rộng - tăng tốc tối đa
    case 0b01111110:
    case 0b00111110:
    case 0b01111100:
      line = 0;
      adjustedSpeed = tocdo + (isHighSpeed ? 25 : 15);
      kd = 4.0; // Giảm D mạnh để chạy mượt
      break;

    default:
      // Sử dụng PID thông thường
      adjustedSpeed = tocdo;
      kd = 8.0;
      break;
  }

  // Áp dụng PID với tốc độ đã điều chỉnh
  handleAndSpeed(pidAdjust, adjustedSpeed);
}

//---------------------------------------------------//
void updateLine() {
  if (sensor == 0xff) beep(100);
  for (int i = 0; i < 8; i++) {
    Serial.print(sensorValue[i]); Serial.print("  ");
    if (black_value[i] == 0) black_value[i] = 1100;
    if (sensorValue[i] < black_value[i]) black_value[i] = sensorValue[i];
    if (sensorValue[i] > white_value[i]) white_value[i] = sensorValue[i];
    compare_value[i] = (black_value[i] + white_value[i]) / 2;
  }
  Serial.println();
}

//---------------------------------------------------//
void readEeprom() {
  for (int i = 0; i < 8; i++) compare_value[i] = EEPROM.read(i) * 4;
}

//---------------------------------------------------//
void handleAndSpeed(int angle, int speed1) {
  int speedLeft = constrain(speed1 + angle, -255, 255);
  int speedRight = constrain(speed1 - angle, -255, 255);
  speed_run(speedLeft, speedRight);
}

//---------------------------------------------------//
void speed_run(int speedDC_left, int speedDC_right) {
  speedDC_left  = constrain(speedDC_left, -255, 255);
  speedDC_right = constrain(speedDC_right, -255, 255);

  // Motor trái
  if (speedDC_left > 0) { 
    analogWrite(LPWM_L, speedDC_left); 
    analogWrite(RPWM_L, 0); 
  }
  else if (speedDC_left < 0) { 
    analogWrite(LPWM_L, 0); 
    analogWrite(RPWM_L, -speedDC_left); 
  }
  else { 
    analogWrite(LPWM_L, 0); 
    analogWrite(RPWM_L, 0); 
  }

  // Motor phải
  if (speedDC_right > 0) { 
    analogWrite(LPWM_R, speedDC_right); 
    analogWrite(RPWM_R, 0); 
  }
  else if (speedDC_right < 0) { 
    analogWrite(LPWM_R, 0); 
    analogWrite(RPWM_R, -speedDC_right); 
  }
  else { 
    analogWrite(LPWM_R, 0); 
    analogWrite(RPWM_R, 0); 
  }
}

//---------------------------------------------------//
void read_sensor() {
  sensorValue[0] = 1023 - analogRead(A7);
  sensorValue[1] = 1023 - analogRead(A6);
  sensorValue[2] = 1023 - analogRead(A5);
  sensorValue[3] = 1023 - analogRead(A4);
  sensorValue[4] = 1023 - analogRead(A3);
  sensorValue[5] = 1023 - analogRead(A2);
  sensorValue[6] = 1023 - analogRead(A1);
  sensorValue[7] = 1023 - analogRead(A0);

  unsigned char temp = 0;
  unsigned int sum = 0;
  unsigned long avg = 0;

  for (int j = 0; j < 8; j++) {
    if (isCalib == 0) {
      if (sensorValue[j] < black_value[j]) sensorValue[j] = black_value[j];
      if (sensorValue[j] > white_value[j]) sensorValue[j] = white_value[j];
      sensorPID[j] = map(sensorValue[j], black_value[j], white_value[j], 0, 1000);
    }
    temp = temp << 1;
    if (sensorValue[j] > compare_value[j]) temp |= 0x01;
    else temp &= 0xfe;
  }
  sensor = temp;

  // Tính PID nâng cao
  for (int j = 0; j < 8; j++) {
    avg += (long)(sensorPID[j]) * (j * 1000);
    sum += sensorPID[j];
  }
  
  if (sum > 0) {
    int i = (int)((avg / sum) - 3500);
    
    // PID động - thay đổi tham số theo tốc độ và độ lệch
    float dynamic_kp = kp;
    float dynamic_kd = kd;
    
    // Tăng P khi lệch nhiều
    if (abs(i) > 2000) dynamic_kp *= 1.3;
    
    // Giảm D khi tốc độ cao để tránh rung
    if (isHighSpeed) dynamic_kd *= 0.8;
    
    int iP = dynamic_kp * i;
    int iD = dynamic_kd * (lastPos - i);
    int iRet = (iP - iD);
    
    // Giới hạn output PID
    if (iRet < -4000) iRet = -4000;
    if (iRet > 4000) iRet = 4000;
    
    servoPwm = iRet / 25; // Chia nhỏ hơn để mượt hơn
    lastPos = i;
  }
}

//---------------------------------------------------//
void beep(int timer) {
  digitalWrite(BUZZER, 1);
  delay(timer);
  digitalWrite(BUZZER, 0);
}

//---------------------------------------------------//
unsigned char sensorMask(unsigned char mask) {
  return (sensor & mask);
}

//---------------------------------------------------//
// Hàm phát hiện góc vuông hoặc giao lộ
int detectIntersection() {
  // Phát hiện góc vuông trái
  if (sensorMask(0xF0) == 0xF0) return -1;
  // Phát hiện góc vuông phải  
  if (sensorMask(0x0F) == 0x0F) return 1;
  // Phát hiện T-junction
  if (sensorMask(0xFF) == 0xFF) return 2;
  return 0;
}
